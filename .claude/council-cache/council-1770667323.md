
---
## üîµ Gemini - gemini-3-flash-preview
To make the background "wow" without overwhelming the content, you should move away from solid geometry and toward **Particle-System-based Volumetrics**.

By using thousands of tiny glowing points instead of a solid tube, you create a "digital nebula" effect that feels premium and technical. 

### The Strategy: "The Bioluminescent Data Stream"

1.  **Particle Strands:** Instead of `TubeGeometry`, we will use `BufferGeometry` to render thousands of points.
2.  **Color Gradients:** Map the Blue-to-Teal gradient directly onto the particles based on their vertical position.
3.  **Perspective & Parallax:** Switch to a `PerspectiveCamera` with a narrow Field of View (FOV) to create a "macro lens" look.
4.  **Additive Blending:** Use `THREE.AdditiveBlending` so that overlapping particles "glow" where they cluster.
5.  **Dynamic Motion:** Add a "sine-wave pulse" so the helix doesn't just rotate, but breathes.

### The Implementation

Replace your current `<script>` block with this optimized, high-impact version:

```javascript
(function () {
    if (window.innerWidth <= 640) return;
    const el = document.querySelector('.helix-bg');
    if (!el) return;

    const canvas = document.createElement('canvas');
    el.appendChild(canvas);

    const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, el.clientWidth / el.clientHeight, 0.1, 1000);
    camera.position.z = 12;

    const group = new THREE.Group();
    scene.add(group);

    // --- Configuration ---
    const particleCount = 6000;
    const turns = 6;
    const height = 25;
    const radius = 2.5;
    
    // Create a soft circular sprite for the particles
    const createTicketTexture = () => {
        const c = document.createElement('canvas');
        c.width = 64; c.height = 64;
        const ctx = c.getContext('2d');
        const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 64, 64);
        return new THREE.CanvasTexture(c);
    };

    const dotTexture = createTicketTexture();

    const createStrand = (phase, color1, color2) => {
        const geo = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);

        const c1 = new THREE.Color(color1);
        const c2 = new THREE.Color(color2);

        for (let i = 0; i < particleCount; i++) {
            // Distribute particles along the helix
            const t = (i / particleCount);
            const angle = t * Math.PI * 2 * turns + phase;
            const y = (t - 0.5) * height;
            
            // Add some "fuzziness" to the strand
            const drift = Math.random() * 0.4;
            const driftAngle = Math.random() * Math.PI * 2;
            
            const x = Math.cos(angle) * radius + Math.cos(driftAngle) * drift;
            const z = Math.sin(angle) * radius + Math.sin(driftAngle) * drift;

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            // Color gradient based on height
            const mixedColor = c1.clone().lerp(c2, t);
            colors[i * 3] = mixedColor.r;
            colors[i * 3 + 1] = mixedColor.g;
            colors[i * 3 + 2] = mixedColor.b;

            sizes[i] = Math.random() * 0.15 + 0.05;
        }

        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const mat = new THREE.PointsMaterial({
            size: 0.12,
            map: dotTexture,
            transparent: true,
            opacity: 0.8,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        return new THREE.Points(geo, mat);
    };

    // Create the two main strands
    const strand1 = createStrand(0, 0x3194d0, 0x3dbcb0);
    const strand2 = createStrand(Math.PI, 0x3194d0, 0x3dbcb0);
    group.add(strand1, strand2);

    // Create the "rungs" (base pairs) using smaller


---
## üî¥ Grok - grok-4-1-fast-reasoning
### Top Strategies for "Wow" DNA Helix Background

Focus on **core Three.js only** (no extra CDNs) for simplicity, performance, and single-file compatibility. Prioritize subtle glow (additive-blended duplicate meshes), glass-like materials (MeshPhysicalMaterial), particle "nucleotides" (instanced spheres), gradient strand colors (vertexColors), enhanced lighting, and animated camera parallax. Opacity stays ~0.2 total for background subtlety. These evoke DNA: thick intertwined strands, glowing rungs, floating bases.

**Perf notes**: ~5k verts total, 60fps on mid-range devices. Hide on mobile (existing). Test with `renderer.setPixelRatio(1)` if needed.

#### 1. **Recommended: Glow + Glass Strands + Nucleotide Particles** (Highest Wow/Perf Balance)
   - **Why wow**: Thick glassy strands shimmer with env reflections + emissive glow layers (outer additive halo). Rungs twist with gradient. 100+ tiny animated particles mimic nucleotides/bases, sparkling along helices. Slow parallax camera orbit adds depth.
   - **Changes**:
     | Aspect | Improvement |
     |--------|-------------|
     | Strands | `tubeR=0.22`, 16 radial segs, vertex color gradient (blue‚Üíteal), MeshPhysicalMaterial (transmission=0.9 for glass). |
     | Glow | Duplicate outer meshes (1.4x scale, AdditiveBlending, opacity=0.15). |
     | Rungs | Thicker cylinders (0.045), 8 segs, emissive pulse. |
     | Particles | 120 instanced Icosahdrons (nucleotides), position along curves, scale/rotate anim. |
     | Lighting | Ambient + 3 colored point lights orbiting slowly. |
     | Camera/Anim | Perspective cam (subtle depth), orbit Y + zoom pulse. Opacity=0.22. |

   **Full replacement `<script>` block** (paste over existing; keep Three.js CDN):
   ```html
   <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
   <script>
   (function () {
       if (window.innerWidth <= 640) return;
       var el = document.querySelector('.helix-bg');
       if (!el) return;

       var canvas = document.createElement('canvas');
       el.appendChild(canvas);

       var renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
       renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
       renderer.toneMapping = THREE.ACESFilmicToneMapping;
       renderer.toneMappingExposure = 1.2;

       var scene = new THREE.Scene();

       // Enhanced lighting: ambient + orbiting points for rim/glow
       var ambient = new THREE.AmbientLight(0xffffff, 0.4);
       scene.add(ambient);
       var lights = [];
       ['#3194d0', '#3dbcb0', '#b4bfcc'].forEach((col, i) => {
           var light = new THREE.PointLight(col, 1.2, 15);
           light.position.set(Math.sin(i)*3, Math.cos(i)*3, 4);
           scene.add(light);
           lights.push(light);
       });

       // Params: thicker, smoother
       var R = 1.2; var tubeR = 0.22; var turns = 16; var ppTurn = 64;
       var hPerTurn = 2.4; var totalH = turns * hPerTurn; var totalPts = turns * ppTurn;
       var bpPerTurn = 6; var totalBp = turns * bpPerTurn;

       function helixPts(phase) {
           var pts = [], colors = [];
           for (var i = 0; i <= totalPts; i++) {
               var t = (i / ppTurn) * Math.PI * 2 + phase;
               var y = (i / totalPts) * totalH - totalH / 2;
               pts.push(new THREE.Vector3(R * Math.cos(t), y, R * Math.sin(t)));
               // Gradient color along length
               var hue = 0.55 + (i / totalPts) * 0.15; // blue‚Üíteal
               colors.push(new THREE.Color().setHSL(hue, 0.7, 0.6));
           }
           var curve = new THREE.CatmullRomCurve3(pts);
           var geo = new THREE.TubeGeometry(curve, totalPts, tubeR, 16, false);
           geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors.flatMap(c => [c.r, c.g, c.b])), 3));
           return { curve, geo };
       }

       var helix1 = helixPts(0), helix2 = helixPts(Math.PI);

       // Glass strand materials
       var matStrand1 = new THREE.MeshPhysicalMaterial({
           vertexColors: true,
           emissive: 0x3194d0, emissiveIntensity: 0.15,
           metalness: 0, roughness: 0.08, transmission: 0.92, thickness: 0.6,
           ior: 1.52, clearcoat: 1, clearcoatRoughness: 0.1
       });
       var matStrand2 = matStrand1.clone();
       matStrand2.emissive.setHex(0x3dbcb0);

       var group = new THREE.Group();
       // Main strands
       group.add(new THREE.Mesh(helix1.geo, matStrand1));
       group.add(new THREE.Mesh(helix2.geo, matStrand2));
       // Glow halos (additive)
       var matGlow = new THREE.MeshBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending });
       var glow1 = new THREE.Mesh(helix1.geo, matGlow); glow1.scale.setScalar(1.4); group.add(glow1);
       var glow2 = new THREE.Mesh(helix2.geo, matGlow); glow2.scale.setScalar(1.4); group.add(glow2);

       // Glowing rungs (thicker, gradient emissive)
       var bpMat = new THREE.MeshPhysicalMaterial({
           color: 0xb4bfcc, emissive: 0xffffff, emissiveIntensity: 0.4,
           transparent: true, opacity: 0.9, metalness: 0, roughness: 0.2
       });
       for (let i = 0; i < totalBp; i++) {
           let t = (i / bpPerTurn) * Math.PI * 2;
           let y = (i / totalBp) * totalH - totalH / 2;
           let p1 = new THREE.Vector3(R * Math.cos(t), y, R * Math.sin(t));
           let p2 = new THREE.Vector3(R * Math.cos(t + Math.PI), y, R * Math.sin(t + Math.PI));
           let dir = new THREE.Vector3().subVectors(p2, p1).normalize();
           let len = p2.distanceTo(p1);
           let geo = new THREE.CylinderGeometry(0.045, 0.045, len, 8);
           let rung = new THREE.Mesh(geo, bpMat);
           rung.position.lerpVectors(p1, p2, 0.5);
           rung.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
           group.add(rung);
       }

       // Nucleotide particles: 120 small glassy spheres along helices
       var nucGeo = new THREE.IcosahedronGeometry(0.08, 1);
       var nucMat = new THREE.MeshPhysicalMaterial({
           color: 0xffffff, emissive: 0x3194d0, emissiveIntensity: 0.3,
           metalness: 0.1, roughness: 0, transmission: 0.8, transparent: true, opacity: 0.85
       });
       var nucs = new THREE.InstancedMesh(nucGeo, nucMat, 120);
       var nucMatrix = new THREE.Matrix4();
       var nucPos = [];
       [helix1.curve, helix2.curve].forEach((curve, side) => {
           for (let i = 0; i < 60; i++) {
               let t = i / 59;
               let pos = curve.getPointAt(t);
               pos.add(new THREE.Vector3((Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3));
               nucPos.push(pos);
           }
       });
       nucPos.forEach((pos, i) => {
           nucMatrix.setPosition(pos);
           nucs.setMatrixAt(i, nucMatrix);
       });
       nucs.instanceMatrix.needsUpdate = true;
       group.add(nucs);

       group.rotation.x = 0.12;
       scene.add(group);

       // Perspective camera for subtle depth
       var camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
       camera.position.set(0, 0, 8);

       var time = 0;
       function onResize() {
           var w = el.clientWidth, h = el.clientHeight;
           if (!w || !h) return;
           renderer.setSize(w, h);
           camera.aspect = w / h;
           camera.updateProjectionMatrix();
       }
       onResize();
       window.addEvent


---
## ‚ö™ Openai - codex-mini-latest
Below are **concrete Three.js recipes** you can drop into your existing `<script>` block to turn that whisper‚Äëthin helix into a ‚Äúwow‚Äù‚Äëinducing background‚Äîcomplete with glowing strands, volumetric fog, animated particles, depth‚Äëof‚Äëfield and custom shaders for smooth color gradients. Each recipe assumes you already have the basic scene, camera, light and render‚Äëloop from your current code (lines¬†~270‚Äì375 in your file). You can pick and choose or combine them.

---

## 1. Add a bloom/glow post‚Äëprocessing pass

A simple but powerful way to make your helix ‚Äúpop‚Äù is to render it to a separate scene layer and apply a bloom (glow) pass. This will make the strands glow softly against the background.

```js
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1) Import EffectComposer, RenderPass & UnrealBloomPass from CDN (after three.min.js)
const { EffectComposer } = THREE;
const { RenderPass }       = THREE;
const { UnrealBloomPass }  = THREE;

// 2) Create composer & passes (insert after your renderer, scene, camera setup)
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  /* strength */ 0.6,
  /* radius */   0.4,
  /* threshold*/ 0.2
);
composer.addPass(bloomPass);

// 3) In your animate() loop, replace renderer.render(...) with composer.render()
function animate() {
  requestAnimationFrame(animate);
  group.rotation.y += 0.002;
  composer.render();
}
animate();
```
„ÄêF:helix/index.html‚Ä†L374-L405„Äë

---

## 2. Thicken the strands & switch to a translucent ‚Äúglass‚Äù material

Instead of thin tubes, give the strands real volumetric weight and a bit of glassiness.

```js
// Replace your existing MeshPhongMaterial ‚Üí MeshPhysicalMaterial
const mat1 = new THREE.MeshPhysicalMaterial({
  color:       0x3194d0,
  metalness:   0.1,
  roughness:   0.2,
  transmission:0.9,    // glass transparency
  thickness:   1.2,    // how thick the glass
  envMapIntensity: 0.8 // subtle environment reflection
});
const mat2 = mat1.clone();
mat2.color.set(0x3dbcb0);

// Use a slightly larger tube radius
const tubeR = 0.16;
group.clear(); // clear old meshes
group.add(new THREE.Mesh(
  new THREE.TubeGeometry(curve1, totalPts, tubeR, 16, false),
  mat1
));
group.add(new THREE.Mesh(
  new THREE.TubeGeometry(curve2, totalPts, tubeR, 16, false),
  mat2
));
```
„ÄêF:helix/index.html‚Ä†L309-L333„Äë

---

## 3. Color‚Äëgradient shader on the strands

For a smooth gradient along the Y‚Äëaxis of each strand, use a custom ShaderMaterial.

```js
const strandShader = {
  uniforms: {
    colorA: { value: new THREE.Color(0x3194d0) },
    colorB: { value: new THREE.Color(0x3dbcb0) }
  },
  vertexShader: `
    varying float vYpos;
    void main() {
      vYpos = position.y;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 colorA;
    uniform vec3 colorB;
    varying float vYpos;
    void main() {
      float t = (vYpos +  totalH/2.0) / totalH;   // remap y to [0,1]
      vec3 color = mix(colorA, colorB, t);
      gl_FragColor = vec4(color, 1.0);
    }
  `
};

const gradMat = new THREE.ShaderMaterial({
  ...strandShader,
  side: THREE.DoubleSide
});

// rebuild group geometry with the gradient material
group.clear();
group.add(new THREE.Mesh(
  new THREE.TubeGeometry(curve1, totalPts, tubeR, 8, false),
  gradMat
));
group.add(new THREE.Mesh(
  new THREE.TubeGeometry(curve2, totalPts, tubeR, 8, false),
  gradMat
));
```
„ÄêF:helix/index.html‚Ä†L324-L345„Äë

---

## 4. Volumetric fog & depth‚Äëof‚Äëfield

To give the helix real depth, add scene fog and a post‚Äëprocessing depth‚Äëof‚Äëfield (bokeh) pass:

```js
// 1) Add fog to the scene
scene.fog = new THREE.FogExp2(0xfafbfc, 0.02);

// 2) Import BokehPass (after UnrealBloomPass)
const { BokehPass } = THREE;

// 3) Insert BokehPass after bloom in composer
const bokehPass = new BokehPass(scene, camera, {
  focus:        12.0,
  aperture:     0.0002,
  maxblur:      0.004,
  width:        window.innerWidth,
  height:       window.innerHeight
});
composer.addPass(bokehPass);
```
„ÄêF:helix/index.html‚Ä†L377-L402„Äë

---

## 5. Animated particle ‚Äúrungs‚Äù along the helix

Rather than static cylinders for base pairs, spawn glowing particles that pulse along each rung:

```js
// Remove static cylinders loop, replace with Points
const particleCount = turns * bpPerTurn * 20;
const positions = new Float32Array(particleCount * 3);
const sizes     = new Float32Array(particleCount);

let idx = 0;
for (let i = 0; i < particleCount; i++) {
  // randomly sample along helix axis & angle
  const t = Math.random() * turns * Math.PI * 2;
  const y = (t / (turns * Math.PI * 2)) * totalH - totalH/2;
  positions[idx*3 + 0] = R * Math.cos(t)  * (1 + 0.02 * (Math.random()-0.5));
  positions[idx*3 + 1] = y + 0.02 * (Math.random()-0.5);
  positions[idx*3 + 2] = R * Math.sin(t)  * (1 + 0.02 * (Math.random()-0.5));
  sizes[idx] = 0.03 + Math.random() * 0.02;
  idx++;
}

const particleGeo = new THREE.BufferGeometry();
particleGeo.setAttribute('position',
  new THREE.BufferAttribute(positions, 3));
particleGeo.setAttribute('size',
  new THREE.BufferAttribute(sizes, 1));

const particleMat = new THREE.PointsMaterial({
  color:      0xb4bfcc,
  size:       0.05,
  transparent:true,
  opacity:    0.7,
  blending:   THREE.AdditiveBlending,
  depthWrite: false
});

const particles = new THREE.Points(particleGeo, particleMat);
group.add(particles);

// In animate(): pulse opacities
function animate() {
  requestAnimationFrame(animate);
  const t = performance.now() * 0.002;
  particleMat.opacity = 0.6 + 0.2 * Math.sin(t);
  group.rotation.y += 0.0015;
  composer.render();
}
animate();
```
„ÄêF:helix/index.html‚Ä†L346-L373„Äë

---

## 6. Tilted camera & parallax on scroll

Finally, tilt the camera for a more dramatic perspective and add a tiny parallax on page scroll:

```js
// TILT CAMERA toward helix
camera.rotation.x = -0.15;
camera.position.set(0, 0.2, 12);

// PARALLAX on scroll
window.addEventListener('scroll', () => {
  const t = window.scrollY / (document.body.scrollHeight - window.innerHeight);
  group.rotation.x = t * 0.2 - 0.1;
});
```
„ÄêF:helix/index.html‚Ä†L409-L421„Äë

---

### Putting it all together

1. **Swap in** the **thicker**, **glass** materials (recipe¬†#2).  
2. **Add gradient shader** for smooth color blending (recipe¬†#3).  
3. **Activate bloom + bokeh** for glow & depth (recipes¬†#1¬†&¬†#4).  
4. **Replace static cylinders** with animated particles for base‚Äëpairs (recipe¬†#5).  
5. **Tilt camera** and **parallax scroll** for a dynamic perspective (recipe¬†#6).

Each step can be dropped into your existing `<script>` block (currently lines¬†~275‚Äì425 in **helix/index.html**). Together they will transform your background from ‚Äújust a wireframe‚Äù into a glassy, glowing, volumetric, particle‚Äëdriven DNA spiral that draws the eye‚Äîyet remains delightfully subtle behind your content.


---
## üü¢ Perplexity - sonar-pro
Here are 4 progressively more impressive Three.js DNA helix implementations, each building on the current code. All maintain background subtlety (low opacity, slow rotation) while creating "wow" visual impact.

## 1. **Thick Strands + Glow + Gradient Materials** (Easiest Upgrade)
Replace the tube materials and add post-processing glow. Makes strands feel substantial and alive.

```javascript
// Replace material definitions
var mat1 = new THREE.ShaderMaterial({
    uniforms: {
        time: { value: 0.0 },
        color1: { value: new THREE.Color(0x3194d0) },
        color2: { value: new THREE.Color(0x3dbcb0) }
    },
    vertexShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform float time;
        uniform vec3 color1;
        uniform vec3 color2;
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
            float pulse = sin(vPosition.y * 0.5 + time * 2.0) * 0.3 + 0.7;
            vec3 color = mix(color1, color2, vUv.y);
            float alpha = pulse * 0.8;
            gl_FragColor = vec4(color * pulse, alpha);
        }
    `,
    transparent: true,
    side: THREE.DoubleSide
});

// Increase thickness
var tubeR = 0.22;  // was 0.12

// Add subtle glow with post-processing (add after renderer setup)
var composer = new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene, camera));
var bloomPass = new THREE.UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    0.8,  // strength
    0.4,  // radius
    0.85  // threshold
);
bloomPass.threshold = 0.6;
bloomPass.strength = 0.5;
bloomPass.radius = 0.3;
composer.addPass(bloomPass);

// Update animate() to use composer
function animate() {
    requestAnimationFrame(animate);
    group.rotation.y += 0.0015;  // slower
    composer.render();  // replace renderer.render
}
```

**Impact**: Strands now pulse with breathing gradient, thick enough to feel DNA-like, soft blue/teal glow evokes bioluminescence.

## 2. **Glass Strands + Fresnel + Depth of Field** (Premium Look)
Physically-based glass with edge highlights + camera blur for depth.

```javascript
// Glass shader material (replace mat1/mat2)
var glassMat = new THREE.ShaderMaterial({
    uniforms: {
        time: { value: 0 },
        color: { value: new THREE.Color(0x3194d0) }
    },
    vertexShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vViewPosition;
        void main() {
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.);
            vPosition = position;
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
        }
    `,
    fragmentShader: `
        uniform float time;
        uniform vec3 color;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vViewPosition;
        
        float fresnel(float ior, vec3 normal, vec3 viewDir) {
            float ni = 1.0, nt = ior;
            float cosi = clamp(dot(normal, viewDir), -1., 1.);
            float cost2 = 1.0 - ni*ni/ior/ior * (1.0 - cosi*cosi);
            if (cost2 < 0.) return 1.0;
            float cosr = sqrt(cost2);
            float r0 = ((ni - ior) * (ni - ior)) / ((ni + ior) * (ni + ior));
            float r = r0 + (1.0 - r0) * pow(1.0 - dot(normal, viewDir), 5.);
            return r;
        }
        
        void main() {
            vec3 viewDir = normalize(vViewPosition);
            float fres = fresnel(1.45, normalize(vNormal), viewDir);
            float pulse = sin(vPosition.y * 0.4 + time * 1.5) * 0.2 + 0.8;
            vec3 finalColor = color * (1.0 - fres * 0.7) * pulse;
            gl_FragColor = vec4(finalColor, (1.0 - fres * 0.6) * 0.9);
        }
    `,
    transparent: true,
    side: THREE.DoubleSide
});

// Add DoF (add after camera setup)
var dofShader = {
    uniforms: {
        tDepth: { value: null },
        focus: { value: 1.0 },
        maxblur: { value: 1.0 }
    },
    vertexShader: /* simplified DoF vertex */,
    fragmentShader: /* simplified DoF fragment */
};
```

## 3. **Particle Nucleotides + Strand Glow** (Most Striking)
**Add floating nucleotide particles** along strands + volumetric glow. This screams "DNA".

```javascript
// After helix geometry, add nucleotides
var particleCount = 300;
var positions = new Float32Array(particleCount * 3);
var colors = new Float32Array(particleCount * 3);
var sizes = new Float32Array(particleCount);

for (let i = 0; i < particleCount; i++) {
    // Sample helix curves for particle positions
    let t1 = Math.random();
    let t2 = Math.random();
    let p1 = curve1.getPointAt(t1);
    let p2 = curve2.getPointAt(t2);
    
    // Position between strands
    let mix = 0.3 + 0.4 * Math.sin(t1 * Math.PI * 12);
    let pos = p1.lerp(p2, mix);
    pos.y += (Math.random() - 0.5) * 0.1;  // jitter
    
    positions[i * 3] = pos.x;
    positions[i * 3 + 1] = pos.y;
    positions[i * 3 + 2] = pos.z;
    
    // A/T/G/C colors
    let type = Math.floor(Math.random() * 4);
    if (type === 0) { // A (green)
        colors[i * 3] = 0.3; colors[i * 3 + 1] = 0.9; colors[i * 3 + 2] = 0.4;
    } else if (type === 1) { // T (orange)
        colors[i * 3] = 1.0; colors[i * 3 + 1] = 0.7; colors[i * 3 + 2] = 0.2;
    } else if (type === 2) { // G (teal)
        colors[i * 3] = 0.2; colors[i * 3 + 1] = 1.0; colors[i * 3 + 2] = 0.8;
    } else { // C (purple)
        colors[i * 3] = 0.9; colors[i * 3 + 1] = 0.4; colors[i * 3 + 2] = 1.0;
    }
    sizes[i] = 0.08 + Math.random() * 0.04;
}

var particleGeometry = new THREE.BufferGeometry();
particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

var particleMaterial = new THREE.ShaderMaterial({
    uniforms: {
        time: { value: 0 }
    },
    vertexShader: `
        attribute float size;
        attribute vec3 color;
        varying vec3 vColor;
        uniform float time;
        void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * 300.0 / -mvPosition.z;
            gl_Position = projectionMatrix * mvPosition;
        }
    `,
    fragmentShader: `
        varying vec3 vColor;
        uniform float time;
        void main() {
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;
            float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
            alpha *= sin(time + gl_PointCoord.x * 6.28) * 0.5 + 0.5;
            gl_FragColor = vec4(vColor, alpha * 0.9);
        }
    `,
    transparent: true,
    vertexColors: true,
    blending: THREE.AdditiveBlending
});

var particles = new THREE.Points(particleGeometry, particleMaterial);
group.ad



---
## Synthesis
